/**
 * Copyright Â© 2022 by Karthik Jain <krthkj.public@gmail.com>
 * All Rights Reserved.
 * Using MIT licence, refer the license file supplied with the project.
 *
 * File : e13.cpp
 * Desc : Section 13: OOP - Class and objects
 *        Challenge from Udemy course "Beginning C++ Programming - From Beginner to Beyond"
 *
 * Author : Karthik Jain <krthkj.public@gmail.com>
 * Date : 2022-12-11
 *
 */

#include "account.hpp"
#include "udemy1.hpp"
#include <iostream>
#include <vector>

namespace udemy1
{

/*
 ***********************************************************************************************
 * Object-Oriented Programming
 ***********************************************************************************************
 * Class and object
 * - Focus is on class and model real-world domain entities
 * - allows to hink at a higher level of abstraction
 * - used succeffully un very large programs.
 ***********************************************************************************************
 * Concepts:
 * - Encapsulation:
 *   - Objects contain data and operations that work on that data
 *   - Abstract Data Type (ADT)
 * - Information hiding
 *   - implementation specific login can be hidden
 *   - users of class code to the interface since they dont need to know the implementations
 *   - more abstraction.
 *   - easier to test, debug, maintain and extend.
 * - Reusability
 *   - easier to reuse class in the applicaitons
 *   - faster development
 *   - higher quality
 * - Inheritance
 *   - create new class in terms of existing class
 *   - reusability
 *   - polymorphic class
 * - Polymorphism and more..
 *   - Overloading
 *   - Overriding
 ***********************************************************************************************
 * Classes:
 * - bluprint of object
 * - has attributes (data)
 * - has methods (functions)
 * - userdefined data-type
 * - can hide data and methods
 * - provide a public interface
 * - Syntax: class Class_Name{
 *           // declerations
 *           };
 *
 * Object:
 * - created from class
 * - represent a specific instance of a class
 * - can create many ojects
 * - each has it own identity
 * - each can use the defined class methods
 * - Syntax: Class_Name object_name;
 ***********************************************************************************************
 * Access class member
 * - using dot operator
 * - using -> (member of pointer or arrow) operator
 * Example:
 * {
 *   Account *frank_account = new Account ();
 *
 *   // dereference the pointer and use dot operator
 *   *frank_account.balance;
 *   *frank_account.deposit(100);
 *
 *   // use -> directly on the pointer.
 *   frank_account->balance;
 *   frank_account->deposit(100);
 *
 * }
 *
 ***********************************************************************************************
 * Class member access modifiers
 * - public    : accessible everywhere
 * - private   : accessible only by members or friends of the class
 * - protected : using with inheritance
 * - friends   : ????????????
 ***********************************************************************************************
 * Implementing member methods:
 * - can be implemented inside the class decleration ( implicitly inline )
 * - can be implemented outside the class decleration ( use '::' scope resolution operator )
 * - Can seperate specificaiton for impelementation
 *   - .h for class decleration
 *   - .cpp for class implementation
 ***********************************************************************************************
 * Include Guards:
 * Ideal method:
 *      #ifndef _FILENAME_H_
 *      #define _FILENAME_H_
 *      // class decleration
 *      #endif // _FILENAME_H_
 *
 * Alternative method: (may not work on some compilers)
 *      #pragma once
 ***********************************************************************************************
 * Constructors
 * - Special member method invoked during object creating
 * - useful for initialization
 * - same name as the class
 * - No return type is specified
 * - can be overloaded
 *
 * Destructors
 * - Special member methods, invoked automatically when an object is destryoyed
 * - same name as class proceded with a tilde (~)
 * - no return type and no parameters
 * - cannot be overloaded.
 * - useful to release memoey and other resources.
 *
 * Note:
 * - for stack objects, Destructors are called in the reverse order of the constructor calls
 ***********************************************************************************************
 * Default constructor
 * - autogenerated by C++ when a no args constructor is defined.
 * - default constructor is no longer compiler-generated once another constructor is declared
 *
 * Overloading constructor
 * - class can have any number of constructors as necessary
 * - must have unique signature
 * - default constructor is no longer compiler-generated once another constructor is declared
 ***********************************************************************************************
 * Constructor Initialization list
 * - more effecient
 * - initializes data members as the oject is created
 * - order of initialization is the order of declaration in the class
 * - Note: data members values are assigned in the constructor body not initialized.
 *         Hence initialization list is true initialization
 *
 * Deligation Constructs
 * - avoids duplicating code, and prevents unnecessory errors.
 * - simplifies constructor initialization list
 *
 * Default Constructor parameters
 * - simplify code, reduce overloading constructors
 ***********************************************************************************************
 * Copy constructor
 * - create new object from existing object
 * - usage: passing object by value
 * - usage: returning object from a funtion by value
 * - usage: constructing object based on another of the same class
 * - if we dont provide, c++ complier will generate, a default copy constructor.
 *
 * Note:
 * - if copy ocnstructor is not porvided, c++ compiler will generate a copy constructor,
 *   which will do member wise copy. (default copy constructor)
 * - if using pointers, default copy constructors will only copy pointers and
 *   not the data pointed by the pointers. (shallow copy)
 *
 * Best practice, copy constructors
 * - always define copy constructor using "const"
 * - create copy constructors when class has raw pointer members
 * - use STL classes as they already provide copy constructors
 * - avoid using raw pointer data members if possible
 * -create copy constructor using deligation
 *
 * Syntax:  Type::Type (const Type &source){ };
 *
 * +==================+====================================+================================+
 * | Type             |     Shallow copy                   |       Deep copy                |
 * +==================+====================================+================================+
 * | copy             |   member wise                      | pointer data is copied         |
 * +------------------+------------------------------------+--------------------------------+
 * |default copy      |   default                          |                                |
 * |  constructor     |                                    |                                |
 * +------------------+------------------------------------+--------------------------------+
 * |  example         | Type::Type (const Type &source)    |Type::Type (const Type &source) |
 * |                  |  : data_member{src.data_member}    | : data_member{*src.data_member}|
 * |                  |  { }                               | { }                            |
 * +------------------+------------------------------------+--------------------------------+
 * |                  |                                    |                                |
 * |                  |                                    |                                |
 * +------------------+------------------------------------+--------------------------------+
 ***********************************************************************************************
 * Move constructor (introduced in C++11) { Move is basically 'stealing' data instead of copy}
 * - Sometimes copy constructors are called many times automatically due to the copy semantics of c++
 * - Copy constructiond doeing deep copy can have significant performace bottle-neck
 * - moves an object instead of copy
 * - Optional but recommended when using raw pointers
 * - copy elision - C++ may optimize copying away completely (RVO - return value optimization)
 * Example:
 *   class Move {
 *   private:
 *      int *data;        // raw pointer
 *   public:
 *      void set_data(int d) { *data = d; }
 *      int get_data()    { return *data; }
 *      Move ();                // Constructor
 *      Move (int d);           // Constructor
 *      Move (const Move &src); // Copy Constructor
 *      ~Move ();               // Destructor
 *   }
 *   Move::Move(): Move{0};                                             // deligated Constructor
 *   Move::Move{int d} {data = new int ; *data = *d.data;}              // Constructor
 *   Move::Move(const Move &src) {data = new int ; *data = *src.data;}  // copy constructor
 *
 ***********************************************************************************************
 * r-value references:
 * - used in moving semantis and perfect forwarding
 * - move sematics is all about r-value reference
 * - used by move constructors and move assignment operator to efficiently more an oject rather than copy
 * - R-value reference operatior (&&)
 * [ Note: r-value reference is considered temporary values ]
 *
 * Rules of r-value references:
 * {
 *   int x {10};        // x is l-value
 *   int &l_ref = x;    // l-val reference
 *   l_ref = 100;       // change x to 100
 *
 *   int &&r_ref = 200; // r-value reference
 *   r_ref = 300;       // change r_ref to 300
 *
 *   int &&x_ref = x;   // compiler error
 * }
 *
 * {
 *   int x {10};            // x is l-value
 *   void func (int &num);  // A
 *   func (x);              // calls A: x is an l-value
 *   func (100);            // ERROR: 200 is an l-value
 *   // error cannot bind non-const lvalue reference to an rvalue type
 * }
 *
 * {
 *   int x {10};            // x is l-value
 *   void func (int &num);  // A
 *   func (x);              // calls A: x is an l-value
 *   func (100);            // ERROR: 200 is an l-value
 *   // error cannot bind non-const lvalue reference to an rvalue type
 * }
 *
 * {
 *   int x {100};            // x is l-value
 *   void func (int &&num);  // B
 *   func (200);             // calls B: 200 is an r-value
 *   func (x);            // ERROR: x is an l-value
 *   // error cannot bind rvalue reference to rvalue type
 * }
 *
 * {
 *   int x {100};            // x is l-value
 *   void func (int &num);   // A
 *   void func (int &&num);  // B
 *   func (x);               // calls A: x is an l-value
 *   func (200);             // calls B: 200 is an r-value
 *   // error cannot bind rvalue reference to rvalue type
 * }
 ***********************************************************************************************
 * this pointer
 * - points to current obejct
 * 
 ***********************************************************************************************
 */

//-----------------------------------------------------------------------------------------

namespace ex1
{

class Player
{
  public:
    // attributes
    std::string name{"Player"};
    int health{100};
    int xp{3};

    // methods
    void talk(std::string test_to_say)
    {
        std::cout << name << " says " << test_to_say << std::endl;
    }

    bool is_dead(void)
    {
        if(health > 0)
            return true;
        return false;
    }
};

class Account
{
  public:
    std::string name{"Account"};
    double balance{0.0};

    void deposit(double amt)
    {
        balance += amt;
        std::cout << "in deposit" << std::endl;
    }
    void withdraw(double amt)
    {
        balance -= amt;
        std::cout << "in withdraw" << std::endl;
    }
};

} // namespace ex1

//-----------------------------------------------------------------------------------------

namespace ex2
{

class Player
{
  private:
    std::string name{"Player"};
    int health{100};
    int xp{3};

  public:
    // implementing member method inside class
    void talk(std::string test_to_say)
    {
        std::cout << name << " says " << test_to_say << std::endl;
    }

    bool is_dead(void)
    {
        if(health > 0)
            return true;
        return false;
    }
};

class Account
{
  private:
    double balance{0.0};

  public:
    std::string name{"Account"};

    // implementing methods declerationd
    void SetBalance(double);
    double GetBalance();

    // implementing member method inside class
    void deposit(double amt)
    {
        balance += amt;
        std::cout << "in deposit" << std::endl;
    }

    void withdraw(double amt)
    {
        balance -= amt;
        std::cout << "in withdraw" << std::endl;
    }
};

// implementing method outside the class
void Account::SetBalance(double bal)
{
    balance = bal;
}
double Account::GetBalance()
{
    return balance;
}

} // namespace ex2

//-----------------------------------------------------------------------------------------

namespace ex3
{

class Account
{
  private:
    std::string name{"Account"};
    double balance{0.0};

  public:
    void set_balance(double bal)
    {
        balance = bal;
    }
    double get_balance()
    {
        return balance;
    }

    void set_name(std::string n)
    {
        name = n;
    }
    std::string get_name()
    {
        return name;
    }

    bool deposit(double);
    bool withdraw(double);
};

bool Account::deposit(double amt)
{
    balance += amt;
    return true;
}

bool Account::withdraw(double amt)
{
    if(balance - amt >= 0) {
        balance -= amt;
        return true;
    }
    return false;
}

} // namespace ex3

//-----------------------------------------------------------------------------------------

void run_class_example(void)
{
    // objects
    ex1::Player frank;
    ex1::Player hero;

    frank.name = "Frank";
    frank.health = 80;
    frank.xp = 15;
    frank.talk("Hi there..!");

    ex1::Player player[]{frank, hero};
    std::vector<ex1::Player> player_vec{frank};
    player_vec.push_back(hero);

    ex1::Player* enemy{nullptr};
    enemy = new ex1::Player();

    (*enemy).name = "Enemy";
    (*enemy).health = 200;
    enemy->xp = 20;

    enemy->talk("I will destroy you!!");
    delete enemy;

    //----------------------------------------
    ex1::Account frank_account;

    frank_account.name = "Frank's account";
    frank_account.balance = 5000;

    frank_account.deposit(1000);
    frank_account.withdraw(1000);
}

//-----------------------------------------------------------------------------------------

void run_class_access(void)
{
    // objects
    ex2::Player frank;
    ex2::Player hero;

    // frank.name = "Frank"; // Error access is private
    // frank.health = 80;    // Error access is private
    // frank.xp = 15;        // Error access is private
    frank.talk("Hi there..!");

    //----------------------------------------
    ex2::Account frank_account;

    frank_account.name = "Frank's account"; // PASS access is public
    // frank_account.balance = 5000;           // Error access is private

    frank_account.deposit(1000);
    frank_account.withdraw(1000);
}

//-----------------------------------------------------------------------------------------

void run_test_class(void)
{
    ex3::Account frank_account;
    frank_account.set_name("Frank's account");
    frank_account.set_balance(1000.0);

    if(frank_account.deposit(200.0))
        std::cout << "Deposit OK" << std::endl;
    else
        std::cout << "Deposit not allowed" << std::endl;

    if(frank_account.withdraw(200.0))
        std::cout << "Withdraw OK" << std::endl;
    else
        std::cout << "Insufficient funds" << std::endl;

    if(frank_account.withdraw(1500.0))
        std::cout << "Withdraw OK" << std::endl;
    else
        std::cout << "Insufficient funds" << std::endl;
}

void run_test_classfile(void)
{
    myclass::Account frank_account;
    frank_account.set_name("Frank's account");
    frank_account.set_balance(1000.0);

    if(frank_account.deposit(200.0))
        std::cout << "Deposit OK" << std::endl;
    else
        std::cout << "Deposit not allowed" << std::endl;

    if(frank_account.withdraw(200.0))
        std::cout << "Withdraw OK" << std::endl;
    else
        std::cout << "Insufficient funds" << std::endl;

    if(frank_account.withdraw(1500.0))
        std::cout << "Withdraw OK" << std::endl;
    else
        std::cout << "Insufficient funds" << std::endl;
}
//-----------------------------------------------------------------------------------------

namespace ex4
{
class Player
{
  private:
    std::string name;
    int health;
    int xp;

  public:
    Player();                                     // no args constructor
    Player(std::string name);                     // overloaded constructor
    Player(std::string name, int health, int xp); // overloaded constructor
    ~Player();                                    // destructor

    void set_name(std::string val)
    {
        name = val;
    }
    void set_health(int val);
    void set_xp(int val);

    std::string get_name(void)
    {
        return name;
    }
    int get_health(void)
    {
        return health;
    }
    int get_xp(void)
    {
        return xp;
    }
};

Player::Player()
{
    set_name("Player");
    std::cout << "No args Constructor called" << std::endl;
    health = 100;
    xp = 1;
}

Player::Player(std::string n)
{
    set_name(n);
    std::cout << "String args Constructor called for : " << get_name() << std::endl;
    set_health(100);
    set_xp(1);
}
Player::Player(std::string n, int h, int x)
{
    set_name(n);
    std::cout << "Three args Constructor called for : " << get_name() << std::endl;
    set_health(h);
    set_xp(x);
}
Player::~Player()
{
    std::cout << "Destructor called for : " << get_name() << std::endl;
}

void Player::set_health(int val)
{
    if(val < 0)
        health = 0;
    else
        health = val;
}
void Player::set_xp(int val)
{
    if(val < 0)
        xp = 0;
    else
        xp = val;
}

} // namespace ex4

void run_construct_destruct(void)
{
    {
        ex4::Player slayer;
        slayer.set_name("slayer");
    }

    {
        ex4::Player frank;
        frank.set_name("Frank");
        ex4::Player hero{"Hero"};
        ex4::Player villain{"Villain", 100, 12};
    }
    ex4::Player* enemy = new ex4::Player("Enemy");
    ex4::Player* level_boss = new ex4::Player("Level Boss", 1000, 0);

    delete enemy;
    delete level_boss;
}

//-----------------------------------------------------------------------------------------

namespace ex5
{
// example class for constructor initialization list
class Player
{
  private:
    std::string name;
    int health;
    int xp;

  public:
    // Constructor initialization list
    Player() // no args constructor
        : name{"None"}
        , health{0}
        , xp{0}
    {
        std::cout << "No args conctructor called: " << name << std::endl;
    }
    Player(std::string n) // string args constructor
        : name{n}
        , health{0}
        , xp{0}
    {
        std::cout << "String args conctructor called: " << name << std::endl;
    }
    Player(std::string n, int h, int x) // three args constructor
        : name{n}
        , health{h}
        , xp{x}
    {
        std::cout << "three args conctructor called: " << name << std::endl;
    }
    ~Player()
    {
        std::cout << "Destructor called: " << name << std::endl;
    }
};

} // namespace ex5

namespace ex6
{
// example class for deligating constructor
class Player
{
  private:
    std::string name;
    int health;
    int xp;

  public:
    // constructors
    Player();
    Player(std::string n);
    Player(std::string n, int h, int x);
    // destructor
    ~Player();
};

Player::Player() // deligating constructor
    : Player{"None", 100, 0}
{
    std::cout << "No args conctructor called: " << name << std::endl;
}

Player::Player(std::string n) // deligating constructor
    : Player{n, 100, 0}
{
    std::cout << "String args conctructor called: " << name << std::endl;
}

Player::Player(std::string n, int h, int x) // constructor initialization list
    : name{n}
    , health{h}
    , xp{x}
{
    std::cout << "three args conctructor called: " << name << std::endl;
}

Player::~Player() // destructor
{
    std::cout << "Destructor called: " << name << std::endl;
}

} // namespace ex6

namespace ex7
{
// example class for deligating constructor
class Player
{
  private:
    std::string name;
    int health;
    int xp;

  public:
    // constructors
    Player(std::string n = "none", int h = 0, int x = 0);
    // destructor
    ~Player();
};

Player::Player(std::string n, int h, int x) // constructor initialization list
    : name{n}
    , health{h}
    , xp{x}
{
    std::cout << "three args conctructor called: " << name << std::endl;
}

Player::~Player() // destructor
{
    std::cout << "Destructor called: " << name << std::endl;
}

} // namespace ex7

void run_construct_variations(void)
{
    {
        std::cout << "### Construction initialization list example ###" << std::endl;
        // example constructor initialization list
        ex5::Player empty;
        ex5::Player frank{"Frank"};
        ex5::Player villain{"Villain", 100, 55};
    }
    std::cout << std::endl;
    {
        std::cout << "### Construction delication example ###" << std::endl;
        // example deligating constructor
        ex6::Player empty;
        ex6::Player frank{"Frank"};
        ex6::Player villain{"Villain", 100, 55};
    }
    std::cout << std::endl;
    {
        std::cout << "### default Constructor parameters example ###" << std::endl;
        // example deligating constructor
        ex7::Player empty;
        ex7::Player frank{"Frank"};
        ex7::Player hero{"Hero", 100};
        ex7::Player villain{"Villain", 100, 55};
    }
}

//-----------------------------------------------------------------------------------------

namespace ex8
{
class Player
{
  private:
    std::string name;
    int health;
    int xp;

  public:
    Player(std::string n = "none", int h = 0, int x = 0); // constructors
    Player(const Player& source);                         // copy constructor
    ~Player();                                            // destructor

    std::string get_name(void)
    {
        return name;
    }
    int get_health(void)
    {
        return health;
    }
    int get_xp(void)
    {
        return xp;
    }
    void display(Player P);
};

// Player::Player(const Player& src) // copy constructor
//     : name{src.name}
//     , health{src.health}
//     , xp{src.xp}
//{
//     std::cout << "copy constructor made copy of " << src.name << std::endl;
// }

Player::Player(const Player& src) // copy constructor with deligation
    : Player{src.name, src.health, src.xp}
{
    std::cout << "copy constructor made copy of " << src.name << std::endl;
}

Player::Player(std::string n, int h, int x) // constructor initialization list
    : name{n}
    , health{h}
    , xp{x}
{
    std::cout << "three args conctructor called: " << name << std::endl;
}

Player::~Player() // destructor
{
    std::cout << "Destructor called: " << name << std::endl;
}

void display_Player(Player P)
{
    std::cout << "Name   " << P.get_name() << std::endl;
    std::cout << "Health " << P.get_health() << std::endl;
    std::cout << "XP     " << P.get_xp() << std::endl;
}

} // namespace ex8

void run_copy_constructs(void)
{
    {
        ex8::Player empty;
        ex8::Player frank{"Frank"};
        ex8::display_Player(empty);
        ex8::Player hero{"Hero", 100};
        ex8::Player villain{"Villain", 100, 55};
    }
}

//-----------------------------------------------------------------------------------------
namespace ex9
{
//-----------------
class Shallow
{
  private:
    int* data;

  public:
    Shallow();                   // Constructor
    Shallow(int d);              // Constructor
    Shallow(const Shallow& src); // copy Constructor
    ~Shallow();                  // destructor

    void set_data(int d)
    {
        *data = d;
    }
    int get_data(void)
    {
        return *data;
    }
};

// Constructor
Shallow::Shallow(int d)
    : data{nullptr}
{
    data = new int;
    *data = d;
    std::cout << "Constructor" << std::endl;
}

Shallow::Shallow()
    : Shallow{0}
{
    std::cout << "no arg Constructor" << std::endl;
}

// copy Constructor
Shallow::Shallow(const Shallow& src)
    : data{src.data}
{
    std::cout << "Copy constructor - Shallow copy" << std::endl;
}

// destructor
Shallow::~Shallow()
{
    if(data != nullptr)
        delete data;
    std::cout << "Destructor called " << std::endl;
}

void display_shallow(Shallow s)
{
    std::cout << s.get_data() << std::endl;
}
//-----------------
class Deep
{
  private:
    int* data;

  public:
    Deep();                // Constructor
    Deep(int d);           // Constructor
    Deep(const Deep& src); // copy Constructor
    ~Deep();               // destructor

    void set_data(int d)
    {
        *data = d;
    }
    int get_data(void)
    {
        return *data;
    }
};

// Constructor
Deep::Deep(int d)
{
    data = new int;
    *data = d;
    std::cout << "Constructor" << std::endl;
}

Deep::Deep()
    : Deep{0}
{
    std::cout << "no arg Constructor" << std::endl;
}

// copy Constructor
// Deep::Deep(const Deep& src)
//{
//    data = new int;
//    *data = *src.data;
//    std::cout << "Copy constructor - Deep copy" << std::endl;
//}

// copy Constructor using deligation
Deep::Deep(const Deep& src)
    : Deep{*src.data}
{
    std::cout << "Copy constructor - Deep copy" << std::endl;
}

// destructor
Deep::~Deep()
{
    if(data != nullptr)
        delete data;
    std::cout << "Destructor freeing data" << std::endl;
}

void display_deep(Deep s)
{
    std::cout << s.get_data() << std::endl;
}
//-----------------
} // namespace ex9

void run_copy_shallow_deep(void)
{
    {
        // Shallow copy example
        ex9::Shallow obj1{100};
        // ex9::display_shallow(obj1); // runtime error: free() double free detected

        // ex9::Shallow obj2{obj1}; // runtime error: free() double free detected
        // obj2.set_data(1000);
        //    ex9::display_shallow(obj1);
    }
    {
        // Deep copy example
        ex9::Deep obj1{100};
        ex9::display_deep(obj1);

        ex9::Deep obj2{obj1};
        ex9::display_deep(obj2);
        obj2.set_data(1000);
        ex9::display_deep(obj2);
    }
}

//-----------------------------------------------------------------------------------------

namespace ex10
{
// Copy constructor ineffectient
class Move_Test
{
  private:
    int* data;

  public:
    void set_data_value(int d)
    {
        *data = d;
    }
    int get_data_value()
    {
        return *data;
    }
    // Constructor
    Move_Test(int d);
    // Copy Constructor
    Move_Test(const Move_Test& source);
    // Destructor
    ~Move_Test();
};

Move_Test::Move_Test(int d)
{
    data = new int;
    *data = d;
    std::cout << "Constructor for: " << d << std::endl;
}

// Copy ctor
Move_Test::Move_Test(const Move_Test& source)
    : Move_Test{*source.data}
{
    std::cout << "Copy constructor  - deep copy for: " << *data << std::endl;
}

Move_Test::~Move_Test()
{
    if(data != nullptr) {
        std::cout << "Destructor freeing data for: " << *data << std::endl;
    } else {
        std::cout << "Destructor freeing data for nullptr" << std::endl;
    }
    delete data;
}

} // namespace ex10

namespace ex11
{
// Effecient Move constructor
class Move_Test2
{
  private:
    int* data;

  public:
    void set_data_value(int d)
    {
        *data = d;
    }
    int get_data_value()
    {
        return *data;
    }
    // Constructor
    Move_Test2(int d);
    // Copy Constructor
    Move_Test2(const Move_Test2& source);
    // Move_Test2 Constructor
    Move_Test2(Move_Test2&& source) noexcept;
    // Destructor
    ~Move_Test2();
};

Move_Test2::Move_Test2(int d)
{
    data = new int;
    *data = d;
    std::cout << "Constructor for: " << d << std::endl;
}

// Copy ctor
Move_Test2::Move_Test2(const Move_Test2& source)
    : Move_Test2{*source.data}
{
    std::cout << "Copy constructor  - deep copy for: " << *data << std::endl;
}

// Move ctor
Move_Test2::Move_Test2(Move_Test2&& source) noexcept
    : data{source.data}
{
    source.data = nullptr;
    std::cout << "Move constructor - moving resource: " << *data << std::endl;
}

Move_Test2::~Move_Test2()
{
    if(data != nullptr) {
        std::cout << "Destructor freeing data for: " << *data << std::endl;
    } else {
        std::cout << "Destructor freeing data for nullptr" << std::endl;
    }
    delete data;
}

} // namespace ex11

void run_move_constructor(void)
{
    {
        std::cout << "#### Ineffecient COPY constructor example ####" << std::endl;
        std::vector<ex10::Move_Test> vec;

        vec.push_back(ex10::Move_Test{10});
        vec.push_back(ex10::Move_Test{20});
        vec.push_back(ex10::Move_Test{30});
        vec.push_back(ex10::Move_Test{40});
        vec.push_back(ex10::Move_Test{50});
        vec.push_back(ex10::Move_Test{60});
        vec.push_back(ex10::Move_Test{70});
        vec.push_back(ex10::Move_Test{80});
    }
    std::cout << std::endl;
    {
        std::cout << "#### effecient MOVE constructor example ####" << std::endl;
        std::vector<ex11::Move_Test2> vec;
        vec.push_back(ex11::Move_Test2{10});
        vec.push_back(ex11::Move_Test2{20});
        vec.push_back(ex11::Move_Test2{30});
        vec.push_back(ex11::Move_Test2{40});
        vec.push_back(ex11::Move_Test2{50});
        vec.push_back(ex11::Move_Test2{60});
        vec.push_back(ex11::Move_Test2{70});
        vec.push_back(ex11::Move_Test2{80});
    }
}

//-----------------------------------------------------------------------------------------

void e13_run(void)
{
    // run_class_example();
    // run_class_access();
    // run_test_class();
    // run_test_classfile();
    // run_construct_destruct();
    // run_construct_variations();
    // run_copy_constructs();
    // run_copy_shallow_deep();
    run_move_constructor();
}

} // namespace udemy1
